#!/usr/bin/env python
patent1 = '''
<patdoc dtd="2.4" status="BUILD 20010518">
<sdobi>
<b100>
<b110><dnum><pdat>H0001993</pdat></dnum></b110>
<b122us><pdat>A statutory invention registration is not a patent. It has the defensive attributes of a patent but does not have the enforceable attributes of a patent. No article or advertisement or the like may use the term patent, or any term suggestive of a patent, when referring to a statutory invention registration. For more specific information on the rights associated with a statutory invention registration see 35 U.S.C.157.</pdat></b122us>
<b130><pdat>H1</pdat></b130>
<b140><date><pdat>20010904</pdat></date></b140>
<b190><pdat>US</pdat></b190>
</b100>
<b200>
<b210><dnum><pdat>08881700</pdat></dnum></b210>
<b211us><pdat>08</pdat></b211us>
<b220><date><pdat>19970625</pdat></date></b220>
</b200>
<b500>
<b510>
<b511><pdat>G06F  752</pdat></b511>
<b516><pdat>7</pdat></b516>
</b510>
<b520>
<b521><pdat>708650</pdat></b521>
</b520>
<b540><stext><pdat>Floating-point division and squareroot circuit with early determination of resultant exponent</pdat></stext></b540>
<b560>
<b561>
<pcit>
<doc><dnum><pdat>4975868</pdat></dnum>
<date><pdat>19901200</pdat></date></doc>
<party-us>
<nam><snm><stext><pdat>Freerksen</pdat></stext></snm></nam>
</party-us>
<pnc><pdat>3647481</pdat></pnc></pcit><cited-by-examiner>
</cited-by-examiner></b561>
<b561>
<pcit>
<doc><dnum><pdat>5309383</pdat></dnum>
<date><pdat>19940500</pdat></date></doc>
<party-us>
<nam><snm><stext><pdat>Kuroiwa</pdat></stext></snm></nam>
</party-us>
<pnc><pdat>3647481</pdat></pnc></pcit><cited-by-examiner>
</cited-by-examiner></b561>
<b561>
<pcit>
<doc><dnum><pdat>5481745</pdat></dnum>
<date><pdat>19960100</pdat></date></doc>
<party-us>
<nam><snm><stext><pdat>Tatsumi</pdat></stext></snm></nam>
</party-us>
<pnc><pdat>708504</pdat></pnc></pcit><cited-by-examiner>
</cited-by-examiner></b561>
<b561>
<pcit>
<doc><dnum><pdat>5619439</pdat></dnum>
<date><pdat>19970400</pdat></date></doc>
<party-us>
<nam><snm><stext><pdat>Yu et al.</pdat></stext></snm></nam>
</party-us>
<pnc><pdat>3647481</pdat></pnc></pcit><cited-by-examiner>
</cited-by-examiner></b561>
<b562><ncit><stext><pdat>Brent, Richard P. and Kung, H. T., “A Regular Layout for Parallel Adders” </pdat><hil><italic><pdat>IEEE Transactions On Computers </pdat></italic></hil><pdat>vol. C-31:260-264 (1982). </pdat></stext></ncit><cited-by-other></cited-by-other></b562>
<b562><ncit><stext><pdat>Santoro, Mark R. et al., “Rounding Algorithms for IEEE Multipliers” 176-183 </pdat><hil><italic><pdat>Proceedings of the 9th Symposium on Computer Arithmetic </pdat></italic></hil><pdat>(1989). </pdat></stext></ncit><cited-by-other></cited-by-other></b562>
<b562><ncit><stext><pdat>Yu, Robert K. and Zyner, Gregory B., “167 MHz Radix-4 Floating Point Multiplier” </pdat><hil><italic><pdat>Proceedings of the 12th Symposium on Computer Arithmetic </pdat></italic></hil><pdat>(1995). </pdat></stext></ncit><cited-by-other></cited-by-other></b562>
<b562><ncit><stext><pdat>“IEEE Standard for Binary Floating-Point Arithmetic”, </pdat><hil><italic><pdat>ANSI/IEEE Std </pdat></italic></hil><pdat>754-1985, New York, The Institute of Electrical and Electronic Engineers, Inc., (1985) p. 7-13 and 27. </pdat></stext></ncit><cited-by-other></cited-by-other></b562>
<b562><ncit><stext><pdat>UlraSPARC™ Programmer Reference Manual, Rev. 1.0, Sun Microsystems, Inc., p. 237 (1995).</pdat></stext></ncit><cited-by-other></cited-by-other></b562>
</b560>
<b570>
<b577><pdat>17</pdat></b577>
<b578us><pdat>1</pdat></b578us>
</b570>
<b580>
<b582><pdat>36471504</pdat></b582>
<b582><pdat>3647365</pdat></b582>
<b582><pdat>36474801</pdat></b582>
<b582><pdat>36474804</pdat></b582>
<b582><pdat>36474806</pdat></b582>
<b582><pdat>36474808</pdat></b582>
<b582><pdat>36474809</pdat></b582>
<b582><pdat>3647481</pdat></b582>
<b582><pdat>364761</pdat></b582>
<b582><pdat>364764</pdat></b582>
<b582><pdat>364765</pdat></b582>
<b582><pdat>364766</pdat></b582>
<b582><pdat>364767</pdat></b582>
<b582><pdat>364752</pdat></b582>
</b580>
<b590><b595><pdat>3</pdat></b595><b596><pdat>5</pdat></b596><b597us>
</b597us></b590>
</b500>
<b700>
<b720>
<b721>
<party-us>
<nam><fnm><pdat>Chin-Chieh</pdat></fnm><snm><stext><pdat>Chao</pdat></stext></snm></nam>
<adr>
<city><pdat>I-Lan</pdat></city>
<ctry><pdat>TW</pdat></ctry>
</adr>
</party-us>
</b721>
</b720>
<b730>
<b731>
<party-us>
<nam><onm><stext><pdat>Sun Microsystems, Inc.</pdat></stext></onm></nam>
<adr><city><pdat>Palo Alto</pdat></city><state><pdat>CA</pdat></state></adr>
</party-us>
</b731>
<b732us>
<pdat>02</pdat>
</b732us>
</b730>
<b740>
<b741>
<party-us>
<nam><fnm><pdat>Forrest E.</pdat></fnm><snm><stext><pdat>Gunnison</pdat></stext></snm></nam>
</party-us>
</b741>
</b740>
<b745>
<b746>
<party-us>
<nam><fnm><pdat>Daniel T.</pdat></fnm><snm><stext><pdat>Pihulic</pdat></stext></snm></nam>
</party-us>
</b746>
<b748us><pdat>3662</pdat></b748us>
</b745>
</b700>
</sdobi>
<sdoab>
<btext>
<para id="P-00001" lvl="0"><ptext><pdat>A circuit calculates the exact biased resultant exponent before calculating the resultant mantissa of a division operation. The circuit includes a carry-save adder, a conditional-sum adder, a multiplexer and a comparator. The conventional carry-save adder receives the biased exponent of the dividend (e1), the one's complement of the biased exponent of the divisor (˜e2), and the bias. The conditional-sum adder receives the sum and carry resultants of the carry-save adder, outputting &amp;lcub;er0&amp;equals;e1&amp;plus;(˜e2)&amp;plus;bias&amp;rcub; and &amp;lcub;er1&amp;equals;e1&amp;plus;(˜e2)&amp;plus;bias&amp;plus;1&amp;rcub;. The comparator controls the multiplexer to respectively select as the resultant exponent either er0 or er1 when the fraction of the dividend is less than or greater than or equal to the fraction of the divisor. A circuit for determining the resultant exponent of a squareroot operation includes a conditional-sum adder, a multiplexer and a selection logic circuit. The conditional-sum adder receives ½ of e2 and an adjusted bias. The adjusted bias is ½ of the bias (incremented if e2 is odd), causing the conditional-sum adder to output &amp;lcub;er0&amp;equals;½e2&amp;plus;adjusted bias&amp;rcub; and &amp;lcub;er1&amp;equals;½e2&amp;plus;adjusted bias&amp;plus;1&amp;rcub;. The selection logic controls the multiplexer to select er0, except in the case in which all three of the following conditions exist: (i) the fraction of the operand has no zeros; (ii) the squareroot operand is even; and (iii) the rounding mode is rounding to positive infinity.</pdat></ptext></para>
</btext>
</sdoab>
<sdode>
<brfsum>
<btext>
<h lvl="1"><stext><pdat>FIELD OF THE INVENTION</pdat></stext></h>
<para id="P-00002" lvl="0"><ptext><pdat>The present invention relates to processors and, more particularly, to circuitry for performing floating-point division and squareroot operations.</pdat></ptext></para>
<h lvl="1"><stext><pdat>BACKGROUND</pdat></stext></h>
<para id="P-00003" lvl="0"><ptext><pdat>Many currently available processors are configured to perform floating-point arithmetic such as, for example, division and squareroot, in compliance with the IEEE Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985). which is incorporated herein by reference. In these processors, the exponent of the result of the operation is generally calculated after the mantissa computation is completed. Thus, the calculation of the resulting exponent is in the critical path of the division and squareroot operations.</pdat></ptext></para>
<para id="P-00004" lvl="0"><ptext><pdat>Moreover, the mantissa computation can require twenty or more processor clock cycles to complete when using double precision. Thus, calculation of the resultant exponent has a relatively long latency. As is well known, the resultant exponent can then be checked for overflow and underflow exceptions, which are defined in the aforementioned IEEE standard.</pdat></ptext></para>
<para id="P-00005" lvl="0"><ptext><pdat>The relatively long latency of the resulting exponent calculation can become problematic in the so-called superscalar type of processor. In particular, because superscalar processors may concurrently execute two or more instructions, an instruction may complete after a later-occurring instruction, which can result in an error. For example, an error may occur if the later-occurring instruction overwrites a register before a prior floating-point division instruction completes and an overflow or underflow exception occurs for a prior floating-point division operation. The error occurs because when an exception occurs during an instruction (i.e., the trapping instruction), the processor is required to abort all subsequent instructions and request a trap. After the trap-handler completes execution of the trapping instruction, the processor is restarted at the instruction immediately after the trapping instruction. Of course, the completion of a subsequent instruction that overwrites a register before the exception is handled by the trap-handler can cause an error in the program execution.</pdat></ptext></para>
<para id="P-00006" lvl="0"><ptext><pdat>Because the resultant exponent is not calculated until late in the instruction execution, a conventional solution to this problem is to make a prediction (before the next subsequent instruction completes) of whether an overflow or underflow exception will occur. In this conventional scheme, a pessimistic prediction is performed to ensure that no overflow or underflow exceptions will be missed by the trap-handler. Of course, pessimistic prediction will result in unnecessary traps, which decreases the performance of the processor. Thus, there is a need for a processor capable of early and exact calculation of the resultant exponent, which both increases performance and allows exact prediction of overflow and underflow.</pdat></ptext></para>
<h lvl="1"><stext><pdat>SUMMARY</pdat></stext></h>
<para id="P-00007" lvl="0"><ptext><pdat>In accordance with the present invention, a floating-point division circuit is provided that calculates the exact biased resultant exponent before calculating the resultant mantissa. In one embodiment, the circuit includes a carry-save adder, a conditional-sum adder, a multiplexer and a comparator. The conventional carry-save adder is coupled to receive the biased exponent of the dividend (e1), the one's complement of the biased exponent of the divisor (˜e2), and the bias (as defined in the aforementioned the ANSI/IEEE Standard for the precision format being used). The ANSI/IEEE Standard specifies that the mantissas of the dividend and operand can be in normalized form.</pdat></ptext></para>
<para id="P-00008" lvl="0"><ptext><pdat>The conditional-sum adder is coupled to receive the sum and carry resultants of the carry-save adder and operates to output the sums &amp;lcub;er0&amp;equals;e1&amp;plus;(˜e2)&amp;plus;bias&amp;rcub; and &amp;lcub;er1&amp;equals;e1&amp;plus;(˜e2)&amp;plus;bias&amp;plus;1&amp;rcub;. The sum er0 is the resultant biased exponent of the division operation when the resultant mantissa is in a normalized form after calculation. Similarly, the sum er1 is the resultant biased exponent of the division operation when the resultant mantissa is not in a normalized form. The comparator provides an output signal that controls the multiplexer to select the sum er1 when the fraction of the dividend is greater than or equal to the fraction of the normalized divisor. Conversely, when the fraction of the normalized dividend is less than the fraction of the normalized divisor, the comparator causes the multiplexer to select the sum er0. Because the operation of the carry-save adder, conditional-sum adder and the comparator is relatively fast, the exact resultant exponent is available for underflow and overflow detection before the next instruction completes, thereby eliminating the need for pessimistic prediction.</pdat></ptext></para>
<para id="P-00009" lvl="0"><ptext><pdat>In another embodiment of the invention adapted for determining the resultant exponent of a floating-point squareroot operation, the circuit includes a conditional-sum adder, a multiplexer and a selection logic circuit. The conditional-sum adder is coupled to receive the biased exponent (e2) of the squareroot operand, divided by two (i.e., right-shifted by one bit) and an adjusted bias. The adjusted bias is the exponent bias divided by two, which is incremented if the exponent e2 is odd (i.e., having a least significant bit equal to one). Thus, the conditional-sum adder outputs the sum &amp;lcub;er0&amp;equals;½e2&amp;plus;adjusted bias&amp;rcub; and the sum &amp;lcub;er1&amp;equals;½e2&amp;plus;adjusted bias&amp;plus;1&amp;rcub;. The resultant mantissa will end up in normalized form after calculation, except in the case in which all three of the following conditions exist: (i) the fraction of the operand has no zeros; (ii) the e2 is even; and (iii) the rounding mode is rounding to positive infinity (as defined in the aforementioned IEEE standard). The selection logic monitors these three conditions and causes the multiplexer to select er0 to output as the biased resultant exponent in all cases except when all three of the above-conditions occur. When all three of these conditions occur, the selection logic causes the multiplexer to select er1 to output as the biased resultant exponent. This embodiment determines the exact biased resultant exponent before the mantissa calculation is completed. Thus, unlike conventional squareroot circuits, the resultant exponent calculation is taken out of the critical path, thereby improving performance.</pdat></ptext></para>
<para id="P-00010" lvl="0"><ptext><pdat>In yet another embodiment, the circuit is adapted to calculate the biased resultant exponent of floating-point division, squareroot and multiplication operations. This embodiment includes a bias selection circuit, a first multiplexer, a second multiplexer, a carry-save adder, a conditional-sum adder, a selection logic circuit and an output multiplexer. The first multiplexer selects either e1 for multiplication and division operations or zero for squareroot operations. The second multiplexer selects e2 for multiplication operations, (˜e2) for division operations or ½e2 for squareroot operations. The bias selection circuit selects the appropriate bias for the precision format (e.g., single or double precision) for division operations or the adjusted bias (for single or double precision) for squareroot operations. The carry-save adder receives the selected output signals of the first and second multiplexers and the bias selection circuit. The conditional-sum adder receives the carry and sum output signals of the carry-save adder and outputs the sums er0 and er1. The selection logic circuit then causes the output multiplexer to select either er0 or er1 as described above for the floating-point division and squareroot embodiments. For floating-point multiplication operations, the selection logic circuit detects whether the mantissa multiplication resultant is normalized or not normalized. If the mantissa is normalized, the selection logic circuit causes the output multiplexer to select er0 and, conversely, if the mantissa is not normalized, the selection logic circuit causes the output multiplexer to select er1.</pdat></ptext></para>
<para id="P-00011" lvl="0"><ptext><pdat>In a further refinement of this embodiment, two conventional overflow and two underfiow detectors may be coupled to respectively receive the er0 and er1 signals from the conditional-sum adder so that the overflow and underflow of er0 and er1 may be determined concurrently with calculation of the multiplication mantissa resultant. The selection logic circuit is also implemented to select the output signals of the appropriate overflow and underflow detectors. This embodiment allows the use of same resultant exponent circuitry (which takes the resultant exponent calculation out of the critical path) for floating-point multiplication, division and squareroot operations. In addition, for the case of multiplication and division operations, the biased resultant exponent is calculated significantly faster, thereby eliminating the need for pessimistic prediction of the overflow or underflow of the resultant exponent.</pdat></ptext></para>
</btext>
</brfsum>
<drwdesc>
<btext>
<h lvl="1"><stext><pdat>BRIEF DESCRIPTION OF THE DRAWINGS</pdat></stext></h>
<para id="P-00012" lvl="0"><ptext><pdat>The foregoing aspects and many of the attendant advantages of this invention will become more readily appreciated as the same becomes better understood by reference to the following detailed description, when taken in conjunction with the accompanying drawings, wherein:</pdat></ptext></para>
<para id="P-00013" lvl="0"><ptext><fgref id="DRAWINGS"><pdat>FIG. 1</pdat></fgref><pdat> is a block diagram of a computer system having a floating-point processor with circuitry for calculating resultant exponents according to the present invention;</pdat></ptext></para>
<para id="P-00014" lvl="0"><ptext><fgref id="DRAWINGS"><pdat>FIG. 2</pdat></fgref><pdat> is a block diagram of a circuit for determining the resultant exponent of floating-point division operations, in accordance with one embodiment of the present invention;</pdat></ptext></para>
<para id="P-00015" lvl="0"><ptext><fgref id="DRAWINGS"><pdat>FIG. 3</pdat></fgref><pdat> is a block diagram of a circuit for determining the resultant exponent of floating-point squareroot operations, in accordance with one embodiment of the present invention;</pdat></ptext></para>
<para id="P-00016" lvl="0"><ptext><fgref id="DRAWINGS"><pdat>FIG. 4</pdat></fgref><pdat> is a logic diagram of a selection logic circuit, in accordance with one embodiment of the present invention;</pdat></ptext></para>
<para id="P-00017" lvl="0"><ptext><fgref id="DRAWINGS"><pdat>FIG. 5</pdat></fgref><pdat> is a block diagram of a block diagram of a circuit for determining the resultant exponent of floating-point multiplication, division and squareroot operations, in accordance with one embodiment of the present invention.</pdat></ptext></para>
</btext>
</drwdesc>
<detdesc>
<btext>
<h lvl="1"><stext><pdat>DETAILED DESCRIPTION</pdat></stext></h>
<para id="P-00018" lvl="0"><ptext><fgref id="DRAWINGS"><pdat>FIG. 1</pdat></fgref><pdat> is a block diagram of an electronic system </pdat><hil><bold><pdat>100</pdat></bold></hil><pdat> having a processor with resultant exponent calculation circuitry in accordance with the present invention. In this embodiment, the processor </pdat><hil><bold><pdat>101</pdat></bold></hil><pdat> is a standard 32-bit Sparc®-type processor configured with the present invention, although the present invention may be incorporated into any suitable processor. For example, the present invention may also be incorporated into X86, Alpha®, MIPS®, HP®, Pentium® and PowerPC® processors.</pdat></ptext></para>
<para id="P-00019" lvl="0"><ptext><pdat>This embodiment of the electronic system </pdat><hil><bold><pdat>100</pdat></bold></hil><pdat> is a computer system having a memory </pdat><hil><bold><pdat>103</pdat></bold></hil><pdat> and interfaces </pdat><hil><bold><pdat>105</pdat></bold></hil><pdat> connected to the processor </pdat><hil><bold><pdat>1</pdat></bold></hil><hil><bold><pdat>01</pdat></bold></hil><pdat>. The interfaces </pdat><hil><bold><pdat>105</pdat></bold></hil><pdat> are in turned connected to peripherals </pdat><hil><bold><pdat>107</pdat></bold></hil><hil><sb><pdat>1</pdat></sb></hil><pdat>-</pdat><hil><bold><pdat>107</pdat></bold></hil><hil><sb><pdat>N</pdat></sb></hil><pdat>, allowing communication between the processor </pdat><hil><bold><pdat>101</pdat></bold></hil><pdat> and these peripherals. Each of the peripherals </pdat><hil><bold><pdat>107</pdat></bold></hil><hil><sb><pdat>1</pdat></sb></hil><pdat>-</pdat><hil><bold><pdat>107</pdat></bold></hil><hil><sb><pdat>N </pdat></sb></hil><pdat>can be any suitable type of peripheral, such as a display, a keyboard, a memory device or any other input/output device. Of course, other embodiments of the present invention can be adapted for use in other types of electronic systems, including for example servers, workstations and controllers.</pdat></ptext></para>
<para id="P-00020" lvl="0"><ptext><fgref id="DRAWINGS"><pdat>FIG. 2</pdat></fgref><pdat> is a block diagram of a circuit </pdat><hil><bold><pdat>200</pdat></bold></hil><pdat> for exactly determining the biased resultant exponent of floating-point division operations before calculation of the resultant mantissa is completed, in accordance with one embodiment of the present invention. As is well known, binary floating-point division is equivalent to division of the operand mantissas and subtraction of the operand exponents. However, because the exponents of the operands are biased, the subtraction of the exponents eliminates the bias, which then must be added in again, as shown below in equation 1:</pdat></ptext></para>
<para id="P-00021" lvl="0"><ptext><f><ptext><pdat>operand1/operand2&amp;equals;(mantissa1/mantissa2)·2</pdat><hil><sp><pdat>e1−e2&amp;plus;bias </pdat></sp></hil><pdat>  (1) </pdat></ptext></f></ptext></para>
<para id="P-00022" lvl="7"><ptext><pdat>where operand1 is the dividend and mantissa1 and e1 respectively are the mantissa and the biased exponent of the dividend, and where operand2 is the divisor and mantissa2 and e2 respectively are the mantissa and biased exponent of the divisor. The circuit </pdat><hil><bold><pdat>200</pdat></bold></hil><pdat> implements in hardware the calculation of the resultant exponent so that the resultant mantissa is in normalized form, as described below.</pdat></ptext></para>
<para id="P-00023" lvl="0"><ptext><pdat>In this embodiment, the circuit </pdat><hil><bold><pdat>200</pdat></bold></hil><pdat> includes a carry-save adder </pdat><hil><bold><pdat>202</pdat></bold></hil><pdat>, a conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat>, a multiplexer </pdat><hil><bold><pdat>206</pdat></bold></hil><pdat> and a comparator </pdat><hil><bold><pdat>208</pdat></bold></hil><pdat>. The carry-save adder </pdat><hil><bold><pdat>202</pdat></bold></hil><pdat> is conventional carry-save adder, which are well known in the art of floating point processors. In floating-point operations compliant with the forementioned ANSI/IEEE Standard 754-1985, each operand of a binary floating-point arithmetic operation can have a normalized mantissa and biased exponent. The standard also specifies the bias for each precision format (e.g., 127 for single precision and 1023 for double precision).</pdat></ptext></para>
<para id="P-00024" lvl="0"><ptext><pdat>The carry-save adder </pdat><hil><bold><pdat>202</pdat></bold></hil><pdat> is coupled to receive the biased exponent e1 of the dividend, the one's complement of the divisor's biased exponent (˜e2), and the bias (as defined in the aforementioned the ANSI/IEEE standard for the precision format being used). The carry-save adder </pdat><hil><bold><pdat>202</pdat></bold></hil><pdat> generates sum and carry resultants, which are received by the conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat>. The conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat> is a conventional conditional-sum adder, which are well known in the art of floating-point processors. For example, the conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat> may be implemented using the conditional-sum adder disclosed in the article “167 MHz Radix-4 Floating Point Multiplier”, Proceedings of the 12</pdat><hil><sb><pdat>th </pdat></sb></hil><pdat>Symposium on Computer Arithmetic, Jul. 19-21, 1995, by R. Yu and G. Zyner. The conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat> outputs the sums according to the equations:</pdat></ptext></para>
<para id="P-00025" lvl="0"><ptext><f><ptext><pdat>er0&amp;equals;e1&amp;plus;(˜e2)&amp;plus;bias   (2)</pdat></ptext></f></ptext></para>
<para id="P-00026" lvl="0"><ptext><f><ptext><pdat>er1&amp;equals;e1&amp;plus;(˜e2)&amp;plus;bias&amp;plus;1   (3)</pdat></ptext></f></ptext></para>
<para id="P-00027" lvl="7"><ptext><pdat>where er0 is the biased resultant exponent of the floating-point division operation when the mantissa calculation results in a non-normalized result, and er1 is the biased resultant exponent of the floating-point division operation when the mantissa calculation results in a non-normalized result.</pdat></ptext></para>
<para id="P-00028" lvl="0"><ptext><pdat>Equations 2 and 3 apply in this embodiment because the mantissas of both the dividend and the divisor are greater than or equal to one and less than two (i.e., in binary form, the mantissa of each operand has an implicit or hidden “1” to the left of the decimal point). Accordingly, the mantissa of the resultant of the division operation must be greater than ½ and less than two. Further, when the fraction (i.e., the portion of the mantissa to the right of the decimal point) of the dividend is less than the fraction of the divisor, the mantissa of the resultant must be greater than ½ and less than one. Therefore, in this case the resultant mantissa is non-normalized (i.e., with a zero to the left of the decimal point) and is right shifted once to be normalized. This right shift of the resultant mantissa requires that the resultant exponent by decreased by one. Further, the biased resultant exponent is the biased exponent of the dividend minus the biased exponent of the divisor. As is well known in binary arithmetic, subtraction of a number is equivalent to the addition of the number's two's complement. However, because the resultant exponent in this case must be decremented by one, the one's complement of the divisor is used. Thus, equation 2 determines the exact biased resultant exponent when the fraction of the dividend is less than the fraction of the divisor.</pdat></ptext></para>
<para id="P-00029" lvl="0"><ptext><pdat>Conversely, when the fraction of the dividend is greater than or equal to the fraction of the divisor, the mantissa of the resultant must be greater than or equal to one and less than two. Therefore, the resultant mantissa (in binary form) has a “1” to the left of the decimal point as shown in the following equation:</pdat></ptext></para>
<para id="P-00030" lvl="0"><ptext><f><ptext><pdat>1.XXXXXX . . . X   (4) </pdat></ptext></f></ptext></para>
<para id="P-00031" lvl="7"><ptext><pdat>where each “X” represents a either a “1” or a “0” (i.e., a “don't care” bit). Thus, in this case, the resultant mantissa is already normalized. Consequently, because only the one's complement of the divisor was added, the resultant exponent must be incremented by one so that, in effect, the two's complement of the divisor was added. Accordingly, equation </pdat><hil><bold><pdat>3</pdat></bold></hil><pdat> determines the exact biased resultant exponent of the floating-point division operation when the mantissa of the dividend is greater than or equal to the mantissa of the divisor.</pdat></ptext></para>
<para id="P-00032" lvl="0"><ptext><pdat>The comparator </pdat><hil><bold><pdat>208</pdat></bold></hil><pdat> is coupled to receive the fractions of the mantissas of the dividend and divisor of the floating-point division operation. The comparator </pdat><hil><bold><pdat>208</pdat></bold></hil><pdat> is a conventional comparator that is configured to provide a control signal ge that controls the multiplexer </pdat><hil><bold><pdat>206</pdat></bold></hil><pdat> to select er1 or er0 as the exact biased resultant exponent er. The control signal ge causes the multiplexer </pdat><hil><bold><pdat>206</pdat></bold></hil><pdat> to output er1 as the biased resultant exponent er when the fraction of the dividend is greater than or equal to the fraction of the divisor. Conversely, when the fraction of the dividend is less than the fraction of the divisor, the comparator </pdat><hil><bold><pdat>208</pdat></bold></hil><pdat> causes the multiplexer </pdat><hil><bold><pdat>206</pdat></bold></hil><pdat> to select er0 as the biased resultant exponent er. In this embodiment, the operation of the carry-save adder </pdat><hil><bold><pdat>202</pdat></bold></hil><pdat>, conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat> and the comparator </pdat><hil><bold><pdat>208</pdat></bold></hil><pdat> is relatively fast (e.g., completed in about one processor clock cycle) and is calculated without waiting for the resultant mantissa calculation, thereby taking the biased resultant exponent calculation out of the critical path to increase the performance of the processor.</pdat></ptext></para>
<para id="P-00033" lvl="0"><ptext><pdat>Further, because the exact biased resultant exponent is available after about one processor clock cycle, a conventional underflow detector </pdat><hil><bold><pdat>210</pdat></bold></hil><pdat> and overflow detector </pdat><hil><bold><pdat>212</pdat></bold></hil><pdat> can be connected to receive the biased resultant exponent er for underflow and overflow detection well before the next instruction completes (e.g., an instruction typically requires at least four processor clock cycles to complete ). Thus, the need for pessimistic prediction of underflow and overflow is eliminated. Accordingly, no unnecessary underflow and overflow traps are executed, which also increases the performance of the processor.</pdat></ptext></para>
<para id="P-00034" lvl="0"><ptext><pdat>In a further refinement of this embodiment, the bias received by the carry-save adder </pdat><hil><bold><pdat>202</pdat></bold></hil><pdat> may be configurable to provide a bias of 127 for a single precision mode and a bias of 1023 for a double precision mode. These bias values are defined in the aforementioned ANSI/IEEE Standard. In light of this disclosure, those skilled in the art of floating point processors can implement a multiplexer to select between the single precision bias and the double precision bias in accordance with the configured precision format.</pdat></ptext></para>
<para id="P-00035" lvl="0"><ptext><fgref id="DRAWINGS"><pdat>FIG. 3</pdat></fgref><pdat> a block diagram of a circuit </pdat><hil><bold><pdat>300</pdat></bold></hil><pdat> for determining the biased resultant exponent of floating-point squareroot operations, in accordance with one embodiment of the present invention. As is well known, finding the resultant squareroot of a normalized floating point operand is equivalent to determining the squareroot of the mantissa of the operand and dividing the operand's exponent by two. However, this operation also reduces the bias by ½; therefore, another ½bias must be added in the exponent calculation so that the resultant exponent is properly biased, as shown in the following equations:</pdat></ptext></para>
<para id="P-00036" lvl="0"><ptext><f><ptext><pdat>SQRT&amp;lcub;1.XXX . . . X·2</pdat><hil><sp><pdat>e2</pdat></sp></hil><pdat>&amp;rcub;  (5) </pdat></ptext></f></ptext></para>
<para id="P-00037" lvl="0"><ptext><f><ptext><pdat>SQRT&amp;lcub;1.XXX . . . X&amp;rcub;·2</pdat><hil><sp><pdat>½2&amp;plus;½bias </pdat></sp></hil><pdat>  (6) </pdat></ptext></f></ptext></para>
<para id="P-00038" lvl="7"><ptext><pdat>where SQRT&amp;lcub; &amp;rcub; represents the squareroot of the number within the brackets. The circuit </pdat><hil><bold><pdat>300</pdat></bold></hil><pdat> implements in hardware the calculation of the biased resultant exponent for the squareroot operation, as described below.</pdat></ptext></para>
<para id="P-00039" lvl="0"><ptext><pdat>In this embodiment, the circuit </pdat><hil><bold><pdat>300</pdat></bold></hil><pdat> includes a conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat>, a multiplexer </pdat><hil><bold><pdat>206</pdat></bold></hil><pdat> and a selection logic circuit </pdat><hil><bold><pdat>302</pdat></bold></hil><pdat>. The conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat> is coupled to receive the biased exponent e2 of the squareroot operand divided by two (i.e., right-shifted by one bit), and an adjusted bias. Thus, the conditional-sum adder outputs sums in the conventional manner according to the following equations:</pdat></ptext></para>
<para id="P-00040" lvl="0"><ptext><f><ptext><pdat>er0&amp;equals;½e</pdat><hil><bold><pdat>2&amp;plus;adjusted bias </pdat></bold></hil><pdat>  (7)</pdat></ptext></f></ptext></para>
<para id="P-00041" lvl="0"><ptext><f><ptext><pdat>er1&amp;equals;½e</pdat><hil><bold><pdat>2&amp;plus;adjusted bias</pdat></bold></hil><pdat>&amp;plus;1   (8)</pdat></ptext></f></ptext></para>
<para id="P-00042" lvl="7"><ptext><pdat>where the adjusted bias is ½ of the normal bias (for the precision format being used), which is incremented if e2 is odd. The adjusted bias is added for the following reason. In binary arithmetic, dividing an exponent by two can be easily implemented by shifting the exponent one place to the right of the decimal point and truncating the least significant bit. Thus, when e2 is even, no accuracy is lost in dividing e2 by two and the adjusted bias remains ½ of the bias specified in the ANSI/IEEE Standard for the precision format being used. However, if e2 is odd, the right shift operation loses the least significant bit, resulting in a loss of accuracy in the resultant exponent. Therefore, e2 is reduced by one while increasing the mantissa by a factor of two. Of course, this adjusted operand is equivalent to the original normalized operand. Then, in dividing the exponent by two, the bias is reduced by a further ½, as shown in the following equations:</pdat></ptext></para>
<para id="P-00043" lvl="0"><ptext><f><ptext><pdat>SQRT&amp;lcub;1X.XXX . . . X·2</pdat><hil><sp><pdat>e2&amp;plus;bias−1</pdat></sp></hil><pdat>&amp;rcub;  (9) </pdat></ptext></f></ptext></para>
<para id="P-00044" lvl="0"><ptext><f><ptext><pdat>SQRT&amp;lcub;1X.XXX . . . X&amp;rcub;·2</pdat><hil><sp><pdat>½2&amp;plus;½bias−½) </pdat></sp></hil><pdat>  (10) </pdat></ptext></f></ptext></para>
<para id="P-00045" lvl="7"><ptext><pdat>where SQRT&amp;lcub; &amp;rcub; represents the squareroot of the operand within the brackets and e2 is odd. In order to properly bias the resultant exponent, an additional (½bias&amp;plus;½) needs to be added to the exponent so that the resultant exponent is equivalent to (½e2&amp;plus;bias). Thus, when e2 is odd, the adjusted bias is (½bias&amp;plus;½) or ½(bias&amp;plus;1). The adjusted biases for even and odd e2 are summarized below in Table 1.</pdat></ptext></para>
<cwu>
<table-us id="TABLE-US-00001">
<table-cals>
<table colsep="0" frame="NONE" rowsep="0">
<tgroup align="LEFT" cols="3" colsep="0" rowsep="0">
<colspec align="LEFT" colname="OFFSET" colwidth="49PT">
<colspec align="CENTER" colname="1" colwidth="21PT">
<colspec align="CENTER" colname="2" colwidth="147PT">
<thead>
<row>
<entry></entry>
<entry nameend="2" namest="OFFSET" rowsep="1"><ptext><pdat>TABLE 1</pdat></ptext></entry>
</row>
<row>
<entry></entry>
<entry align="CENTER" nameend="2" namest="OFFSET" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry><ptext><pdat>e2</pdat></ptext></entry>
<entry><ptext><pdat>adjusted bias</pdat></ptext></entry>
</row>
<row>
<entry></entry>
<entry align="CENTER" nameend="2" namest="OFFSET" rowsep="1"></entry>
</row>
</thead>
<tbody valign="TOP">
<row>
<entry></entry>
<entry><ptext><pdat>even</pdat></ptext></entry>
<entry><ptext><pdat>½ bias</pdat></ptext></entry>
</row>
<row>
<entry></entry>
<entry><ptext><pdat>odd</pdat></ptext></entry>
<entry><ptext><pdat>½ (bias &amp;plus; 1)</pdat></ptext></entry>
</row>
<row>
<entry></entry>
<entry align="CENTER" nameend="2" namest="OFFSET" rowsep="1"></entry>
</row>
</tbody>
</colspec></colspec></colspec></tgroup>
</table>
</table-cals>
</table-us>
</cwu>
<para id="P-00046" lvl="7"><ptext><pdat>It can be shown that the squareroot of a normalized operand (i.e., greater than or equal to one but less than two) is between 1 and the square root of two, inclusive. Thus, the resultant mantissa of the squareroot of a normalized operand mantissa is always normalized. In addition, it can be shown that the squareroot of an operand greater than or equal to two and less than four (i.e., the “even e2” mantissa) is greater than or equal to the square root of two and less than two. Consequently, the resultant mantissa of the squareroot of the adjusted mantissa in the “even e2” case is also always normalized. Because the resultant mantissa is always normalized, there can be no overflow or underflow. Thus, the resultant exponent er will always be equivalent to er0 as provided by the conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat>, except in the rounding case described below.</pdat></ptext></para>
<para id="P-00047" lvl="0"><ptext><pdat>The ANSI/IEEE Standard includes a rounding mode called round to positive infinity (rp). In this rounding mode, the resultant mantissa calculation may not always result in a normalized number. In particular, the resultant mantissa after the squareroot operation may not be in normalized form under the following conditions: (i) the operand mantissa has no zeros; (ii) e2 is even; and (iii) the rounding mode is rounding to positive infinity (as defined in the aforementioned ANSI/IEEE Standard). As can be shown, when the operand mantissa has no zeros, the squareroot of this mantissa will also have no zeros. As defined in the ANSI/IEEE Standard, in the rp rounding mode, if the resultant mantissa has any “1”s to the right of the least significant bit for the precision format (i.e., bit </pdat><hil><bold><pdat>52</pdat></bold></hil><pdat> for double precision and bit </pdat><hil><bold><pdat>23</pdat></bold></hil><pdat> for single precision), then a “1” is added to the least significant bit. As a result, the resultant mantissa is rounded to two (i.e., 10.0 . . . 0 in binary representation). Therefore, in order to normalize the resultant mantissa, the mantissa should be right shifted by one place and the resultant exponent incremented.</pdat></ptext></para>
<para id="P-00048" lvl="0"><ptext><pdat>In the circuit </pdat><hil><bold><pdat>300</pdat></bold></hil><pdat>, this operation is achieved by selecting the er1 result from the conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat>. More specifically, the multiplexer </pdat><hil><bold><pdat>206</pdat></bold></hil><pdat> is connected to receive er0 and er1 from the conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat> and to receive a select control signal from the selection logic circuit </pdat><hil><bold><pdat>302</pdat></bold></hil><pdat>. The selection logic circuit </pdat><hil><bold><pdat>302</pdat></bold></hil><pdat> monitors the three conditions described above and causes the multiplexer </pdat><hil><bold><pdat>206</pdat></bold></hil><pdat> to select er0 as the biased resultant exponent er in all cases except when all three of the above-conditions occur. That is, the selection logic circuit </pdat><hil><bold><pdat>302</pdat></bold></hil><pdat> functions as a decoder of the squareroot operand's fraction, biased exponent e2 and the rounding mode. When all three of these conditions occur, the selection logic circuit </pdat><hil><bold><pdat>302</pdat></bold></hil><pdat> causes the multiplexer </pdat><hil><bold><pdat>206</pdat></bold></hil><pdat> to select er1 as the biased resultant exponent er. In this manner, the circuit </pdat><hil><bold><pdat>300</pdat></bold></hil><pdat> determines the exact resultant biased exponent before the mantissa calculation is completed. Consequently, unlike conventional squareroot circuits, the resultant exponent calculation is taken out of the critical path, thereby improving performance.</pdat></ptext></para>
<para id="P-00049" lvl="0"><ptext><fgref id="DRAWINGS"><pdat>FIG. 4</pdat></fgref><pdat> is a logic diagram showing an embodiment of the selection logic circuit </pdat><hil><bold><pdat>302</pdat></bold></hil><pdat>, according to the present invention. The selection logic circuit </pdat><hil><bold><pdat>302</pdat></bold></hil><pdat> is implemented with two AND gates in this embodiment, AND gates </pdat><hil><bold><pdat>400</pdat></bold></hil><pdat> and </pdat><hil><bold><pdat>402</pdat></bold></hil><pdat>. The AND gate </pdat><hil><bold><pdat>400</pdat></bold></hil><pdat> is connected to receive each bit of the fraction of the operand. Because in double and single precision the fraction is respectively 52-bits and 23-bits, the AND gate </pdat><hil><bold><pdat>400</pdat></bold></hil><pdat> is provided with default “1”s for the input leads not used during single precision operation. Thus, the AND gate </pdat><hil><bold><pdat>400</pdat></bold></hil><pdat> outputs a “1” when all of the bits of the fraction are “1”. The output lead of the AND gate </pdat><hil><bold><pdat>400</pdat></bold></hil><pdat> is connected to an input lead of a three-input AND gate </pdat><hil><bold><pdat>402</pdat></bold></hil><pdat>. The other two input leads of the AND gate </pdat><hil><bold><pdat>402</pdat></bold></hil><pdat> are connected to receive a signal e2_even indicating when at a logic high level that the biased exponent e2 is even, and a signal rp_set indicating when at a logic high level that the rounding mode is rp. Thus, when all of the signals received by the selection logic circuit </pdat><hil><bold><pdat>302</pdat></bold></hil><pdat> are “1”s, the AND gate </pdat><hil><bold><pdat>402</pdat></bold></hil><pdat> outputs a “1” that causes the multiplexer </pdat><hil><bold><pdat>206</pdat></bold></hil><pdat> (</pdat><fgref id="DRAWINGS"><pdat>FIG. 3</pdat></fgref><pdat>) to select er1 from the conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat>. Of course, if any of the received signals are a “0”, then the AND gate </pdat><hil><bold><pdat>402</pdat></bold></hil><pdat> outputs a “0”, which causes the multiplexer </pdat><hil><bold><pdat>206</pdat></bold></hil><pdat> to select er0. Of course, those skilled in the art can design other logic circuits or decoders providing equivalent logic functionality without undue experimentation.</pdat></ptext></para>
<para id="P-00050" lvl="0"><ptext><fgref id="DRAWINGS"><pdat>FIG. 5</pdat></fgref><pdat> is a block diagram of a circuit </pdat><hil><bold><pdat>500</pdat></bold></hil><pdat> adapted to calculate the resultant exponent of floating-point division, squareroot and multiplication operations. This embodiment includes a bias selection circuit </pdat><hil><bold><pdat>502</pdat></bold></hil><pdat>, a first multiplexer </pdat><hil><bold><pdat>504</pdat></bold></hil><pdat>, a second multiplexer </pdat><hil><bold><pdat>506</pdat></bold></hil><pdat>, a carry-save adder </pdat><hil><bold><pdat>202</pdat></bold></hil><pdat>, a conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat>, a selection logic circuit </pdat><hil><bold><pdat>508</pdat></bold></hil><pdat> and an output multiplexer </pdat><hil><bold><pdat>206</pdat></bold></hil><pdat>.</pdat></ptext></para>
<para id="P-00051" lvl="0"><ptext><pdat>The first multiplexer </pdat><hil><bold><pdat>504</pdat></bold></hil><pdat> is connected to receive the biased exponent e1 of the first operand and a hardwired zero. The first multiplexer </pdat><hil><bold><pdat>504</pdat></bold></hil><pdat> is controlled to select e1 for multiplication and division operations and to select zero for squareroot operations.</pdat></ptext></para>
<para id="P-00052" lvl="0"><ptext><pdat>The second multiplexer </pdat><hil><bold><pdat>506</pdat></bold></hil><pdat> is connected to receive the biased exponent e2 of the second operand, the one's complement of the biased exponent of the second operand (˜e2), and the biased exponent of the second operand divided by two (½e2). The second multiplexer is controlled to select e2 for multiplication operations, (˜e2) for division operations or ½e2 for squareroot operations.</pdat></ptext></para>
<para id="P-00053" lvl="0"><ptext><pdat>The bias selection circuit </pdat><hil><bold><pdat>502</pdat></bold></hil><pdat> is connected to receive the true and one's complement of the biases (as defined in the ANSI/IEEE Standard) and adjusted biases (as described above in conjunction for squareroot operations) for single precision and double precision formats. For the precision format being used (i.e., single or double precision), the bias selection circuit </pdat><hil><bold><pdat>502</pdat></bold></hil><pdat> is controlled to select the appropriate true bias for division operations, the one's complemented bias (˜bias) for multiplication operations, or the adjusted bias for squareroot operations.</pdat></ptext></para>
<para id="P-00054" lvl="0"><ptext><pdat>The carry-save adder </pdat><hil><bold><pdat>202</pdat></bold></hil><pdat> receives the selected output signals of the first and second multiplexers </pdat><hil><bold><pdat>504</pdat></bold></hil><pdat> and </pdat><hil><bold><pdat>506</pdat></bold></hil><pdat> and the bias selection circuit </pdat><hil><bold><pdat>502</pdat></bold></hil><pdat>. Thus, for division operations, the carry-save adder </pdat><hil><bold><pdat>202</pdat></bold></hil><pdat> receives e1, (˜e2) and bias. As a result, the carry-save adder </pdat><hil><bold><pdat>202</pdat></bold></hil><pdat> and the conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat> are equivalent in function to the carry-save adder </pdat><hil><bold><pdat>202</pdat></bold></hil><pdat> and the conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat> in the circuit </pdat><hil><bold><pdat>200</pdat></bold></hil><pdat>, described previously in conjunction with FIG. </pdat><hil><bold><pdat>2</pdat></bold></hil><pdat>. Likewise, for squareroot operations, the carry-save adder </pdat><hil><bold><pdat>202</pdat></bold></hil><pdat> receives zero, ½e2, and adjusted bias. Because the carry-save adder </pdat><hil><bold><pdat>202</pdat></bold></hil><pdat> receives a zero for the first operand, the conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat> in the circuit </pdat><hil><bold><pdat>500</pdat></bold></hil><pdat> is equivalent in function to the conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat> in the circuit </pdat><hil><bold><pdat>300</pdat></bold></hil><pdat>, described previously in conjunction with FIG. </pdat><hil><bold><pdat>3</pdat></bold></hil><pdat>.</pdat></ptext></para>
<para id="P-00055" lvl="0"><ptext><pdat>However, for multiplication operations, the carry-save adder </pdat><hil><bold><pdat>202</pdat></bold></hil><pdat> receives e1, e2,and (˜bias)&amp;plus;1. The bias is complemented for multiplication operations because, as is well known in floating-point arithmetic, multiplication is equivalent to multiplication of the operand mantissas and addition of the operand exponents. However, the sum of two biased exponents results in the biasing being doubled. The proper biasing can then be achieved by subtracting the bias from the sum of the exponents. As previously stated, in binary arithmetic, subtraction is equivalent to addition of the two's complement of the number to be subtracted.</pdat></ptext></para>
<para id="P-00056" lvl="0"><ptext><pdat>The conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat> receives the carry and sum output signals of the carry-save adder </pdat><hil><bold><pdat>202</pdat></bold></hil><pdat> and outputs the sums er0 and er1. For division and squareroot operations, the conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat> operates as previously described in conjunction with </pdat><fgref id="DRAWINGS"><pdat>FIGS. 2 and 3</pdat></fgref><pdat>, respectively. Similarly, in multiplication operations, the conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat> outputs er0 and er1, with er0 representing the biased resultant exponent when the resultant mantissa multiplication results in a number in normalized form, and er1 representing the biased resultant exponent when the resultant mantissa multiplication results in a number greater than or equal to two (which requires that the the resultant exponent to be incremented because only the one's complement of the bias was added). The resultant exponents of the multiplication mode are shown in the following equations:</pdat></ptext></para>
<para id="P-00057" lvl="0"><ptext><f><ptext><pdat>er0&amp;equals;e</pdat><hil><bold><pdat>1&amp;plus;e</pdat></bold></hil><pdat>2&amp;plus;(˜bias)&amp;plus;1   (11)</pdat></ptext></f></ptext></para>
<para id="P-00058" lvl="0"><ptext><f><ptext><pdat>er1&amp;equals;e</pdat><hil><bold><pdat>1&amp;plus;e</pdat></bold></hil><pdat>2&amp;plus;(˜bias)&amp;plus;1&amp;plus;1   (12) </pdat></ptext></f></ptext></para>
<para id="P-00059" lvl="7"><ptext><pdat>where (˜bias) is the one's complement of the bias for the precision format (single or double precision) being used.</pdat></ptext></para>
<para id="P-00060" lvl="0"><ptext><pdat>In this embodiment, in addition to being received by the multiplexer </pdat><hil><bold><pdat>206</pdat></bold></hil><pdat>, er0 and er1 from the conditional-sum adder </pdat><hil><bold><pdat>204</pdat></bold></hil><pdat> are also received by conventional overflow and underflow detectors for division and multiplication operations. Thus, unlike the circuits </pdat><hil><bold><pdat>200</pdat></bold></hil><pdat> (</pdat><fgref id="DRAWINGS"><pdat>FIG. 2</pdat></fgref><pdat>) and </pdat><hil><bold><pdat>300</pdat></bold></hil><pdat> (</pdat><fgref id="DRAWINGS"><pdat>FIG. 3</pdat></fgref><pdat>) in which selection of er0 and er1 is made before detecting overflow and underflow, in the circuit </pdat><hil><bold><pdat>500</pdat></bold></hil><pdat> selection of er0 and er1 is made after the overflow and underflow is detected for both er0 and er1 for both division and multiplication. Then a multiplexer </pdat><hil><bold><pdat>510</pdat></bold></hil><pdat> is used to select the set of overflow and underflow detectors proper for the arithmetic operation being performed. The circuit </pdat><hil><bold><pdat>500</pdat></bold></hil><pdat> does the overflow and underflow detection before selection because, in this embodiment, the selection process for the floating point multiplication operation is not completed until the end of the mantissa calculation (i.e., the resultant exponent determination is in the critical path). Thus, detecting underflow and overflow before selection slightly increases the performance of the multiplication operation, but at the cost of additional circuitry.</pdat></ptext></para>
<para id="P-00061" lvl="0"><ptext><pdat>The selection logic circuit </pdat><hil><bold><pdat>508</pdat></bold></hil><pdat> includes the comparator </pdat><hil><bold><pdat>208</pdat></bold></hil><pdat> (described above in conjunction with </pdat><fgref id="DRAWINGS"><pdat>FIG. 2</pdat></fgref><pdat>) and the selection logic circuit </pdat><hil><bold><pdat>302</pdat></bold></hil><pdat> (described above in conjunction with FIG. </pdat><hil><bold><pdat>3</pdat></bold></hil><pdat>). In addition, the selection logic circuit </pdat><hil><bold><pdat>508</pdat></bold></hil><pdat> includes a subcircuit </pdat><hil><bold><pdat>512</pdat></bold></hil><pdat> for detecting if the resultant mantissa of the multiplication operation is greater than or equal to two. In one embodiment, the output leads of the comparator </pdat><hil><bold><pdat>208</pdat></bold></hil><pdat>, selection logic circuit </pdat><hil><bold><pdat>302</pdat></bold></hil><pdat> and the subcircuit </pdat><hil><bold><pdat>512</pdat></bold></hil><pdat> are received by an OR gate (not shown) to provide the selection control signal for the multiplexer </pdat><hil><bold><pdat>206</pdat></bold></hil><pdat>. In this embodiment, each of these subelements of the selection logic circuit </pdat><hil><bold><pdat>508</pdat></bold></hil><pdat> have a default output signal of “0” when the processor is not performing the arithmetic operation corresponding to the subelement. Thus, the selection logic circuit </pdat><hil><bold><pdat>508</pdat></bold></hil><pdat> causes the output multiplexer </pdat><hil><bold><pdat>206</pdat></bold></hil><pdat> to select either er0 or er1 as described above for the floating-point division and squareroot embodiments. For floating-point multiplication operations, the subcircuit </pdat><hil><bold><pdat>512</pdat></bold></hil><pdat> of the selection logic circuit </pdat><hil><bold><pdat>508</pdat></bold></hil><pdat> detects whether the resultant multiplication mantissa is normalized or not normalized. In one embodiment of the subcircuit </pdat><hil><bold><pdat>512</pdat></bold></hil><pdat>, the subcircuit </pdat><hil><bold><pdat>512</pdat></bold></hil><pdat> simply outputs a signal having a logic value equal to the second bit to the left of the decimal point of the resultant mantissa of the multiplication operation to indicate whether the resulting mantissa is in normalized form. If the resultant mantissa is in normalized form, the selection logic circuit </pdat><hil><bold><pdat>508</pdat></bold></hil><pdat> causes the output multiplexer </pdat><hil><bold><pdat>206</pdat></bold></hil><pdat> to select er0 and, conversely, if the mantissa is not normalized, the selection logic circuit </pdat><hil><bold><pdat>508</pdat></bold></hil><pdat> causes the output multiplexer </pdat><hil><bold><pdat>206</pdat></bold></hil><pdat> to select er1.</pdat></ptext></para>
<para id="P-00062" lvl="0"><ptext><pdat>Of course, in other embodiments, the selection control circuit </pdat><hil><bold><pdat>508</pdat></bold></hil><pdat> may include different logic circuitry to generate the selection control signal for the output multiplexer </pdat><hil><bold><pdat>206</pdat></bold></hil><pdat>. For example, a multiplexer (not shown) can be used instead of the OR gate to select the output signal from the comparator </pdat><hil><bold><pdat>208</pdat></bold></hil><pdat>, selection logic circuit </pdat><hil><bold><pdat>302</pdat></bold></hil><pdat> or the subcircuit </pdat><hil><bold><pdat>512</pdat></bold></hil><pdat> for division, squareroot or multiplication operations, respectively. In addition, the selected output signal can then be used to select the proper set of overflow and underflow detectors (i.e., the set of detectors receiving er0 or the set receiving er1 ).</pdat></ptext></para>
<para id="P-00063" lvl="0"><ptext><pdat>In a further refinement of this embodiment, two conventional overflow and two underflow detectors may be coupled to respectively receive the er0 and er1 signals from the conditional-sum adder so that the overflow and underflow of er0 and er1 may be determined concurrently with calculation of the multiplication mantissa resultant. The selection logic circuit is also implemented to select the output signals of the appropriate overflow and underflow detectors. This embodiment allows the use of same resultant exponent circuitry (which takes the resultant exponent calculation out of the critical path) for floating-point multiplication, division and squareroot operations. In addition, for the case of multiplication and division operations, the resultant exponent is calculated significantly faster, thereby eliminating the need for pessimistic prediction of the overflow or underflow of the resultant exponent. The methodology of the embodiments described above is further described in co-pending and co-filed patent application Ser. No. 08/882,250 by the present inventor, which is incorporated herein by reference.</pdat></ptext></para>
<para id="P-00064" lvl="0"><ptext><pdat>The embodiments of the floating-point division and squareroot circuitry of the present invention described above are illustrative of the principles of this invention and are not intended to limit the invention to the particular embodiments described. For example, while the embodiments described are configured for use in a thirty-two-bit word length system, other embodiments can be adapted by those skilled in the art of floating-point processors for use in systems with different word lengths. In another example, those skilled in the art can combine the division and squareroot circuits without the multiplication circuit. Accordingly, while the preferred embodiment of the invention has been illustrated and described, it will be appreciated that in light of the present disclosure various changes can be made to the described embodiments without departing from the spirit and scope of the invention.</pdat></ptext></para>
</btext>
</detdesc>
</sdode>
<sdocl>
<h lvl="1"><stext><pdat>The embodiments of the invention in which an exclusive property or privilege is claimed are defined as follows: </pdat></stext></h>
<cl>
<clm id="CLM-00001">
<para id="P-00065" lvl="0"><ptext><pdat>1. A circuit for determining a resultant exponent of a floating-point division operation of a dividend and divisor, the dividend and divisor each having a fraction and a biased exponent, the circuit comprising:</pdat></ptext></para>
<clmstep lvl="2"><ptext><pdat>an adder circuit configured to receive the biased dividend exponent (e1), a one's complement of the biased divisor exponent (</pdat><hil><sp><pdat>˜</pdat></sp></hil><pdat>e2) and a bias, wherein said adder circuit generates output sums er0 and er1, wherein sum er0 is equal to e1 &amp;plus;(</pdat><hil><sp><pdat>˜</pdat></sp></hil><pdat>e2)&amp;plus;bias, and sum er‘b is equal to er0&amp;plus;1; </pdat></ptext></clmstep>
<clmstep lvl="2"><ptext><pdat>a multiplexer coupled to receive the sums er0 and er1 from said adder circuit; and </pdat></ptext></clmstep>
<clmstep lvl="2"><ptext><pdat>a selection logic circuit coupled to said multiplexer, and coupled to receive the dividend fraction and the divisor fraction, wherein said selection logic circuit causes said multiplexer to select the sum er0 when the dividend fraction is less than the divisor fraction without waiting for a result of a mantissa computation. </pdat></ptext></clmstep>
</clm>
<clm id="CLM-00002">
<para id="P-00066" lvl="0"><ptext><pdat>2. The circuit of claim </pdat><hil><bold><pdat>1</pdat></bold></hil><pdat> wherein said selection logic causes said multiplexer to select the sum er1 when the dividend fraction is greater than or equal to the divisor fraction.</pdat></ptext></para>
</clm>
<clm id="CLM-00003">
<para id="P-00067" lvl="0"><ptext><pdat>3. The circuit of claim </pdat><hil><bold><pdat>2</pdat></bold></hil><pdat> wherein said selection logic comprises a comparator coupled to receive the divisor fraction and the dividend fraction.</pdat></ptext></para>
</clm>
<clm id="CLM-00004">
<para id="P-00068" lvl="0"><ptext><pdat>4. The circuit of claim </pdat><hil><bold><pdat>1</pdat></bold></hil><pdat> wherein said adder circuit comprises a carry-save adder and a conditional-sum adder.</pdat></ptext></para>
</clm>
<clm id="CLM-00005">
<para id="P-00069" lvl="0"><ptext><pdat>5. The circuit of claim </pdat><hil><bold><pdat>4</pdat></bold></hil><pdat> wherein said carry-save adder is coupled to receive the biased dividend exponent (e1), the one's complement of the biased divisor exponent (</pdat><hil><sp><pdat>˜</pdat></sp></hil><pdat>e2) and the bias.</pdat></ptext></para>
</clm>
<clm id="CLM-00006">
<para id="P-00070" lvl="0"><ptext><pdat>6. The circuit of claim </pdat><hil><bold><pdat>1</pdat></bold></hil><pdat> further comprising a underflow detector and an overflow detector, said underflow and overflow detectors coupled to receive the sum selected by said multiplexer.</pdat></ptext></para>
</clm>
<clm id="CLM-00007">
<para id="P-00071" lvl="0"><ptext><pdat>7. The circuit of claim </pdat><hil><bold><pdat>1</pdat></bold></hil><pdat> further comprising a first and second underflow detectors and a first and second overflow detectors, said first underflow and overflow detectors coupled to receive the sum er0 from said adder circuit, and said second underflow and overflow detectors coupled to receive the sum er1 from said adder circuit.</pdat></ptext></para>
</clm>
<clm id="CLM-00008">
<para id="P-00072" lvl="0"><ptext><pdat>8. A circuit for determining a resultant exponent of a floating-point squareroot operation of an operand having a fraction and a biased exponent (e2), the circuit comprising:</pdat></ptext></para>
<clmstep lvl="2"><ptext><pdat>an adder circuit configured to receive e2 and a constant B, wherein said constant B is a bias when e2is even and the bias&amp;plus;1 when e2 is odd wherein said adder is configured output sums er0 and er1, wherein er0 is equal to ½(e2&amp;plus;B), and er1 is equal to er0&amp;plus;1; </pdat></ptext></clmstep>
<clmstep lvl="2"><ptext><pdat>a multiplexer coupled to receive the sums er0 and er1 from said adder circuit; and </pdat></ptext></clmstep>
<clmstep lvl="2"><ptext><pdat>a selection logic circuit coupled to said multiplexer, wherein said selection logic circuit is configured to cause said multiplexer to select the sum er1 when the fraction of the operand has no zeros, e2 is even, and said circuit is configured in a round to positive infinity mode. </pdat></ptext></clmstep>
</clm>
<clm id="CLM-00009">
<para id="P-00073" lvl="0"><ptext><pdat>9. The circuit of claim </pdat><hil><bold><pdat>8</pdat></bold></hil><pdat> wherein said selection logic circuit is further configured to select the sum er1 only when the fraction of the operand has no zeros, e2 is even, and said circuit is configured in a round to positive infinity mode.</pdat></ptext></para>
</clm>
<clm id="CLM-00010">
<para id="P-00074" lvl="0"><ptext><pdat>10. The circuit of claim </pdat><hil><bold><pdat>8</pdat></bold></hil><pdat> wherein said selection logic circuit is further configured to select the sum er0 when any of the following conditions are true: the operand has a zero, e2 is odd, or said circuit is not configured in the round to positive infinity mode.</pdat></ptext></para>
</clm>
<clm id="CLM-00011">
<para id="P-00075" lvl="0"><ptext><pdat>11. The circuit of claim </pdat><hil><bold><pdat>8</pdat></bold></hil><pdat> wherein said adder circuit comprises a conditional-sum adder.</pdat></ptext></para>
</clm>
<clm id="CLM-00012">
<para id="P-00076" lvl="0"><ptext><pdat>12. A circuit for determining a resultant exponent of a floating-point division operation during a division mode, a floating-point squareroot operation during a squareroot mode and a floating-point multiplication operation during a multiplication mode, each operand of the division, squareroot and multiplication operations having a normalized mantissa and a biased exponent, each mantissa having a fraction, the circuit comprising:</pdat></ptext></para>
<clmstep lvl="2"><ptext><pdat>a first multiplexer configured to receive the biased exponent (e1) of the first operand and a zero, wherein said first multiplexer is selectably configured to provide as an output operand at an output port of said first multiplexer either zero during the squareroot mode or e1 during the division and multiplication modes; </pdat></ptext></clmstep>
<clmstep lvl="2"><ptext><pdat>a second multiplexer configured to receive the biased exponent (e2) of the second operand, ½e2, and a one's complement of e2 (˜e2), wherein said second multiplexer is selectably configured to provide as an output operand at an output port of said second multiplexer either e2 during the multiplication mode, ½e2 during the squareroot mode or ˜e2 during the division mode; </pdat></ptext></clmstep>
<clmstep lvl="2"><ptext><pdat>a third multiplexer configured to receive constants B</pdat><hil><bold><pdat>1</pdat></bold></hil><pdat>-B</pdat><hil><bold><pdat>4</pdat></bold></hil><pdat>, B</pdat><hil><bold><pdat>1</pdat></bold></hil><pdat> being equal to a bias, B2 being equal to the ½(bias), B</pdat><hil><bold><pdat>3</pdat></bold></hil><pdat> being equal to ½(bias&amp;plus;1), and B</pdat><hil><bold><pdat>4</pdat></bold></hil><pdat> being equal to a one's complement of the bias, wherein said third multiplexer is selectably configured to provide as an output operand at an output port of said third multiplexer either B</pdat><hil><bold><pdat>1</pdat></bold></hil><pdat> during the division mode, B</pdat><hil><bold><pdat>2</pdat></bold></hil><pdat> during the squareroot mode when e2 is even, B</pdat><hil><bold><pdat>3</pdat></bold></hil><pdat> during the squareroot mode when e2 is odd, and B</pdat><hil><bold><pdat>4</pdat></bold></hil><pdat> during the multiplication mode; </pdat></ptext></clmstep>
<clmstep lvl="2"><ptext><pdat>an adder circuit having first, second and third input ports respectively coupled to said output ports of said first, second and third multiplexers, wherein said adder circuit is configured output sums er0 and er1, wherein er0 is equal to a sum of the output operands of said first, second and third multiplexers, and wherein er1 is equal to er0&amp;plus;1; </pdat></ptext></clmstep>
<clmstep lvl="2"><ptext><pdat>a fourth multiplexer coupled to receive er0 and er1 from said adder circuit; and </pdat></ptext></clmstep>
<clmstep lvl="2"><ptext><pdat>a selection logic circuit coupled to said fourth multiplexer, wherein said selection logic circuit is configured to cause said fourth multiplexer to select the sum er1 when: </pdat></ptext></clmstep>
<clmstep lvl="2"><ptext><pdat>the first operand's fraction is greater than or equal to the second operand's fraction when said circuit is in the division mode, </pdat></ptext></clmstep>
<clmstep lvl="2"><ptext><pdat>the second operand's fraction has no zeros, e2 is even, and said circuit is configured in the squareroot mode with a round to positive infinity rounding mode, and </pdat></ptext></clmstep>
<clmstep lvl="2"><ptext><pdat>a product of the mantissas of the first and second operands is greater than or equal to two when the circuit is in the multiplication mode. </pdat></ptext></clmstep>
</clm>
<clm id="CLM-00013">
<para id="P-00077" lvl="0"><ptext><pdat>13. The circuit of claim </pdat><hil><bold><pdat>12</pdat></bold></hil><pdat> wherein said adder circuit comprises a carry-save adder and a conditional-sum adder.</pdat></ptext></para>
</clm>
<clm id="CLM-00014">
<para id="P-00078" lvl="0"><ptext><pdat>14. The circuit of claim </pdat><hil><bold><pdat>12</pdat></bold></hil><pdat> wherein said selection logic circuit comprises a comparator configured to receive the fractions of the operands during the division mode.</pdat></ptext></para>
</clm>
<clm id="CLM-00015">
<para id="P-00079" lvl="0"><ptext><pdat>15. The circuit of claim </pdat><hil><bold><pdat>12</pdat></bold></hil><pdat> wherein said selection logic circuit further comprises a decoder configured to receive the fraction of the second operand, a first signal, and a second signal, said first signal having a logic one value when the circuit is in the round to positive infinity rounding mode, and said second signal having a logic one value when e2 is even.</pdat></ptext></para>
</clm>
<clm id="CLM-00016">
<para id="P-00080" lvl="0"><ptext><pdat>16. The circuit of claim </pdat><hil><bold><pdat>12</pdat></bold></hil><pdat> further comprising first and second underflow detectors and first and second underflow detectors, said first underflow and overflow detectors coupled to receive er0 from said adder circuit, and said second underflow and overflow detectors coupled to receive er1 from said adder circuit.</pdat></ptext></para>
</clm>
<clm id="CLM-00017">
<para id="P-00081" lvl="0"><ptext><pdat>17. The circuit of claim </pdat><hil><bold><pdat>12</pdat></bold></hil><pdat> wherein the bias is equal to 127 when the circuit is operating in a single precision mode and </pdat><hil><bold><pdat>1023</pdat></bold></hil><pdat> when the circuit is operating in a double precision mode.</pdat></ptext></para>
</clm>
</cl>
</sdocl>
<sdodr id="DRAWINGS">
<emi file="USH0001993-20010904-D00000.TIF" id="EMI-D00000">
<emi file="USH0001993-20010904-D00001.TIF" id="EMI-D00001">
<emi file="USH0001993-20010904-D00002.TIF" id="EMI-D00002">
<emi file="USH0001993-20010904-D00003.TIF" id="EMI-D00003">
</emi></emi></emi></emi></sdodr>
</patdoc>
<!DOCTYPE PATDOC PUBLIC "-//USPTO//DTD ST.32 US PATENT GRANT V2.4 2000-09-20//EN">
'''


from bs4 import BeautifulSoup,SoupStrainer

#f = open('../Data/Patent_Grant_Full_Text_Data_SGML_Version_2.4_JAN_2001_DEC_2001/pg010904.sgm', 'r')
#print "reading in data"
#data = f.read()

print "handing to beautiful soup"
soup = BeautifulSoup(patent1)

import pdb
pdb.set_trace()
print "finding tags"
topics = soup.findAll('sdoab') # find all abstract tags

print len(topics)  # print number of abstract tags in sgm file

#i=0
#for link in topics:         #loop through each body tag and print its content 
#    children = link.findChildren()
#    for child in children:
#        if i==0:
#            print child
#        else:
#            print "none"
#            i=i+1

#print i


